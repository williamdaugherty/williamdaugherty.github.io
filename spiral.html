
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Rotating Multiple Line Animation</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="animationCanvas"></canvas>

    <script>
        const canvas = document.getElementById('animationCanvas');
        const ctx = canvas.getContext('2d');
        let width, height, centerX, centerY;

        let circles = [];
        const ballCounts = [1100, 2000, 4000, 8000, 16000];
        let currentBallIndex = 3;

        const speedMultipliers = [1, 2, 0.5]; // Normal speed, double speed, half speed
        let currentSpeedIndex = 0;

        const sizes = [5, 15, 25, 40]; // Small, medium, large
        let currentSizeIndex = 0; // Start with smallest size

        const rotationSpeeds = [Math.PI / 540, Math.PI / 270, Math.PI / 180, Math.PI / 90, Math.PI / 60]; // Different rotation speeds
        let currentRotationSpeedIndex = 3;

        let backgroundColor = getRandomColor();
        let targetBackgroundColor = backgroundColor;
        let isFlashing = false; // Initially set to fading mode
        let transitionProgress = 0; // Track the progress of the fade
        let lastBackgroundChange = Date.now();
        let isColorFrozen = false; // Initially, the color is not frozen

        let angle = 0; // Angle in radians
        const emitterCounts = [3, 5, 7];
        let currentEmitterIndex = 0;

        const offScreenDistance = 200; // Distance beyond the screen where circles are removed

        function resizeCanvas() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            centerX = width / 2;
            centerY = height / 2;
        }

        function getRandomColor() {
            return `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;
        }

        function getComplementaryColor(color) {
            const rgb = color.match(/\d+/g);
            return `rgb(${255 - rgb[0]}, ${255 - rgb[1]}, ${255 - rgb[2]})`;
        }

        function interpolateColor(color1, color2, factor) {
            const c1 = color1.match(/\d+/g).map(Number);
            const c2 = color2.match(/\d+/g).map(Number);
            const result = c1.map((val, index) => Math.round(val + factor * (c2[index] - val)));
            return `rgb(${result[0]}, ${result[1]}, ${result[2]})`;
        }

        class Circle {
            constructor() {
                this.reset();
            }

            reset() {
                this.x = centerX;
                this.y = centerY;
                this.radius = sizes[currentSizeIndex];
                this.color = getComplementaryColor(backgroundColor);
                this.baseSpeed = 3 + Math.random() * 2;
                this.speed = this.baseSpeed * speedMultipliers[currentSpeedIndex];
                
                // Determine the direction based on the current angle and one of the current emitter directions
                const emitters = emitterCounts[currentEmitterIndex];
                const angleOffset = (Math.floor(Math.random() * emitters) * (2 * Math.PI / emitters)) + angle;
                this.vx = Math.cos(angleOffset) * this.speed;
                this.vy = Math.sin(angleOffset) * this.speed;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;

                // Reset position when the circle goes far enough off-screen
                if (this.x < -offScreenDistance || this.x > width + offScreenDistance ||
                    this.y < -offScreenDistance || this.y > height + offScreenDistance) {
                    this.reset();
                }
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.closePath();
            }

            updateColor(newColor) {
                this.color = getComplementaryColor(newColor);
            }

            updateSpeed() {
                this.speed = this.baseSpeed * speedMultipliers[currentSpeedIndex];
                const emitters = emitterCounts[currentEmitterIndex];
                const angleOffset = (Math.floor(Math.random() * emitters) * (2 * Math.PI / emitters)) + angle;
                this.vx = Math.cos(angleOffset) * this.speed;
                this.vy = Math.sin(angleOffset) * this.speed;
            }

            updateSize() {
                this.radius = sizes[currentSizeIndex];
            }
        }

        function initCircles(num) {
            circles = [];
            for (let i = 0; i < num; i++) {
                circles.push(new Circle());
            }
        }

        function updateBackgroundColor() {
            if (isColorFrozen) return;

            if (isFlashing) {
                if (Date.now() - lastBackgroundChange >= 1000) { // 1 second interval
                    backgroundColor = getRandomColor();
                    lastBackgroundChange = Date.now();

                    // Update circles' color to complement the new background color
                    circles.forEach(circle => {
                        circle.updateColor(backgroundColor);
                    });
                }
            } else {
                transitionProgress += 0.01; // Increase the progress of the fade
                if (transitionProgress >= 1) {
                    backgroundColor = targetBackgroundColor;
                    targetBackgroundColor = getRandomColor();
                    transitionProgress = 0;
                } else {
                    const interpolatedColor = interpolateColor(backgroundColor, targetBackgroundColor, transitionProgress);
                    backgroundColor = interpolatedColor;

                    // Update circles' color to complement the interpolated background color
                    circles.forEach(circle => {
                        circle.updateColor(interpolatedColor);
                    });
                }
            }
        }

        function cycleBallCount() {
            currentBallIndex = (currentBallIndex + 1) % ballCounts.length;
            initCircles(ballCounts[currentBallIndex]);
        }

        function cycleSpeed() {
            currentSpeedIndex = (currentSpeedIndex + 1) % speedMultipliers.length;
            circles.forEach(circle => {
                circle.updateSpeed();
                circle.updateSize(); // Ensure the size is updated with speed
            });
        }

        function cycleEmitters() {
            currentEmitterIndex = (currentEmitterIndex + 1) % emitterCounts.length;
            circles.forEach(circle => circle.reset());
        }

        function cycleRotationSpeed() {
            currentRotationSpeedIndex = (currentRotationSpeedIndex + 1) % rotationSpeeds.length;
        }

        function cycleSize() {
            currentSizeIndex = (currentSizeIndex + 1) % sizes.length;
            circles.forEach(circle => {
                circle.updateSize(); // Ensure the size is updated
            });
        }

        function toggleColorMode() {
            isFlashing = !isFlashing;
            if (!isFlashing) {
                targetBackgroundColor = getRandomColor(); // Set the next target color
                transitionProgress = 0;
            }
        }

        function toggleColorFreeze() {
            isColorFrozen = !isColorFrozen;
            if (!isColorFrozen) {
                lastBackgroundChange = Date.now(); // Resume color change with current time
            }
        }

        function animate() {
            ctx.fillStyle = backgroundColor;
            ctx.fillRect(0, 0, width, height);

            // Update the angle by the current rotation speed
            angle += rotationSpeeds[currentRotationSpeedIndex];

            circles.forEach(circle => {
                circle.update();
                circle.draw();
            });

            updateBackgroundColor();

            requestAnimationFrame(animate);
        }

        window.addEventListener('resize', resizeCanvas);
        canvas.addEventListener('click', cycleBallCount);
        window.addEventListener('keydown', function(event) {
            switch (event.code) {
                case 'Space':
                    cycleSpeed();
                    break;
                case 'KeyC':
                    toggleColorMode();
                    break;
                case 'KeyS':
                    cycleSize();
                    break;
                case 'KeyX':
                    toggleColorFreeze();
                    break;
                case 'KeyL':
                    cycleEmitters();
                    break;
                case 'KeyR':
                    cycleRotationSpeed();
                    break;
            }
        });

        resizeCanvas();
        initCircles(ballCounts[currentBallIndex]); // Initialize with the first number of circles
        animate();

	 let pages = ['lava.html', 'bounce.html', 'space.html', 'spiral.html'];
    let intervalId;

    function navigateTo(page) {
        clearInterval(intervalId); // Stop the interval
        localStorage.removeItem('randomNavigation'); // Exit random mode
        window.location.href = page;
    }

    function navigateToRandomPage() {
        let randomPageIndex = Math.floor(Math.random() * pages.length);
        navigateTo(pages[randomPageIndex]);
    }

    function setupRandomNavigation() {
        if (localStorage.getItem('randomNavigation') === 'true') {
            intervalId = setInterval(navigateToRandomPage, 30000); // Change page every 30 seconds
        }
    }

    // Set up the random navigation if it was previously activated
    setupRandomNavigation();
</body>
</html>
